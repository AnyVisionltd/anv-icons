"use strict";

exports.__esModule = true;
exports.isCompilable = isCompilable;
exports.default = dirCommand;

var _fs = _interopRequireDefault(require("fs"));

var _util = require("util");

var _path = _interopRequireDefault(require("path"));

var _chalk = _interopRequireDefault(require("chalk"));

var _outputFileSync = _interopRequireDefault(require("output-file-sync"));

var _core = require("@svgr/core");

var _util2 = require("./util");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

const access = (0, _util.promisify)(_fs.default.access);
const readdir = (0, _util.promisify)(_fs.default.readdir);

async function exists(file) {
  try {
    await access(file);
    return true;
  } catch (error) {
    return false;
  }
}

function rename(relative, ext, filenameCase) {
  const relativePath = _path.default.parse(relative);

  relativePath.ext = `.${ext}`;
  relativePath.base = null;
  relativePath.name = (0, _util2.transformFilename)(relativePath.name, filenameCase);
  return _path.default.format(relativePath);
}

const COMPILABLE_EXTENSIONS = ['.svg', '.SVG'];

function isCompilable(filename) {
  const ext = _path.default.extname(filename);

  return COMPILABLE_EXTENSIONS.includes(ext);
}

function defaultIndexTemplate(filePaths) {
  const exportEntries = filePaths.map(filePath => {
    const basename = _path.default.basename(filePath, _path.default.extname(filePath));

    const exportName = /^\d/.test(basename) ? `Svg${basename}` : basename;
    return `export { default as ${exportName} } from './${basename}'`;
  });
  return exportEntries.join('\n');
}

function getDefaultExtension(options) {
  return options.typescript ? 'tsx' : 'js';
}

async function dirCommand(program, filenames, _ref) {
  let {
    ext,
    filenameCase = _util2.CASE.PASCAL
  } = _ref,
      options = _objectWithoutPropertiesLoose(_ref, ["ext", "filenameCase"]);

  async function write(src, dest) {
    if (!isCompilable(src)) return {
      transformed: false,
      dest: null
    };
    ext = ext || getDefaultExtension(options);
    dest = rename(dest, ext, filenameCase);
    const code = await (0, _util2.convertFile)(src, options);

    const cwdRelative = _path.default.relative(process.cwd(), dest);

    const logOutput = `${src} -> ${cwdRelative}\n`;

    if (program.ignoreExisting && (await exists(dest))) {
      (0, _util2.politeWrite)(program, _chalk.default.grey(logOutput));
      return {
        transformed: false,
        dest
      };
    }

    (0, _outputFileSync.default)(dest, code);
    (0, _util2.politeWrite)(program, _chalk.default.white(logOutput));
    return {
      transformed: true,
      dest
    };
  }

  async function generateIndex(dest, files) {
    const indexFile = _path.default.join(dest, `index.${ext}`);

    const config = _core.loadConfig.sync(options, {
      filePath: indexFile
    });

    const indexTemplate = config.indexTemplate || defaultIndexTemplate;

    _fs.default.writeFileSync(indexFile, indexTemplate(files));
  }

  async function handle(filename, root) {
    const stats = await (0, _util2.stat)(filename);

    if (stats.isDirectory()) {
      const dirname = filename;
      const files = await readdir(dirname);
      const results = await Promise.all(files.map(async relativeFile => {
        const absFile = _path.default.join(dirname, relativeFile);

        return handle(absFile, root);
      }));
      const transformed = results.filter(result => result.transformed);

      if (transformed.length) {
        const destFiles = results.map(result => result.dest).filter(Boolean);

        const dest = _path.default.resolve(program.outDir, _path.default.relative(root, dirname));

        await generateIndex(dest, destFiles);
      }

      return {
        transformed: false,
        dest: null
      };
    }

    const dest = _path.default.resolve(program.outDir, _path.default.relative(root, filename));

    return write(filename, dest);
  }

  await Promise.all(filenames.map(async file => {
    const stats = await (0, _util2.stat)(file);
    const root = stats.isDirectory() ? file : _path.default.dirname(file);
    await handle(file, root);
  }));
}